# _Pomegranate-s-fe-testing
front-end test

## 可读性、可维护性 保证测试代码的维护成本小于业务代码

### 准备测试数据

内联
低层次的代码，测试数据简单
一开始可以使用内联的方式
当测试数据变得复杂的时候 进行重构

委托：使用一个函数
中高层次的代码，测试数据复杂
可读性更高，利用函数参数、可以和内联方式联合使用
放到对应的文件夹中「helpers」

隐式
使用 beforeEach、每一个测试 case 都需要用到
导致代码分割、可读性变了 --》 可以使用 describe 来包裹需要用到同样测试数据的测试，在 describe 中的 beforEach 去创建测试数据

可以一上来就使用内联、之后再使用重构手法重构

### 后门操作准备数据的方式
// 调用非公开api 的方式来准备测试数据
优先使用 round-trip 的方式，但是如果我们此时没有 addTodo 这个方法的话就可以先使用后门的方式，之后有 addTodo 了再对这个代码进行重构

后门方式准备测试数据会，因为跟我们的业务代码逻辑可能会高度重合，使这个测试变得很脆弱，这样的代码多了，我们对我们自己的单元测试就会不信任了，之后不得不放弃这些测试

## 最小准备数据原则
在准备测试数据的时候，和当前要测试的功能无关的数据不需要提供
保持单元测试的可读性
给数据一些默认值，只传我们需要的
委托-工厂函数 来隐藏不需要的函数
虚拟对象的方式

## 程序的间接输入
调用其它

第三方库的函数调用 vi.mocked(axios.get).mockResolvedValue()

全局Object -》直接修改属性、方法

class 借助 mock 的方式，prototype 方法赋值

常量 借助 mock 的方式，如果想保留其它的导出的方法的话可以使用这个 mock 的函数参数

环境变量 vitest 的 api
nodejs: process.env --> 直接赋值（）
vite webpack: import.meta.env

全局glob vitest 的 api
调用 window 上的一些属性和方法
调用第三方库的时候挂载到了 window 上

间接层的处理技巧 间接层 + vi.mock
这个间接层就是一个函数 或者一个对象

依赖注入
程序强依赖第三方库、第三方模块「测试程序的时候就必须解决第三方库的问题」
解决：强依赖的模块使用参数的形式传入
